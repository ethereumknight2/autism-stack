<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ü•´ AUTISM STACK 100 üöÄ - The Ultimate Can Stacking Memecoin</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Comic Neue", cursive;
        background: linear-gradient(
          45deg,
          #ff1493,
          #00ffff,
          #ff4500,
          #9400d3,
          #ffff00,
          #ff69b4
        );
        background-size: 400% 400%;
        animation: gradientShift 6s ease infinite;
        overflow-x: hidden;
        min-height: 100vh;
        user-select: none;
      }

      @keyframes gradientShift {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }

      .container {
        position: relative;
        z-index: 10;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }

      h1,
      h2,
      h3,
      p {
        text-align: center;
        color: #fff;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      }

      h1 {
        font-size: 4rem;
        font-weight: 700;
        margin-bottom: 20px;
        animation: titleBounce 2s ease-in-out infinite;
      }

      @keyframes titleBounce {
        0%,
        100% {
          transform: scale(1) rotate(-2deg);
        }
        50% {
          transform: scale(1.05) rotate(2deg);
        }
      }

      .subtitle {
        font-size: 1.5rem;
        color: #000;
        background: linear-gradient(45deg, #3bd5ff, #1ee92c);
        padding: 10px 20px;
        border-radius: 50px;
        display: block;
        margin: 20px auto;
        animation: wiggle 1.5s ease-in-out infinite;
        text-shadow: 1px 1px 0px #fff;
        text-align: center;
        width: fit-content;
      }

      @keyframes wiggle {
        0%,
        100% {
          transform: rotate(-3deg);
        }
        25% {
          transform: rotate(3deg);
        }
        75% {
          transform: rotate(-1deg);
        }
      }

      .tokenomics {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        padding: 30px;
        margin: 40px 0;
        text-align: center;
        animation: cardFloat 4s ease-in-out infinite;
      }

      /* CTA Button Styles */
      .cta-button {
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        color: white;
        font-size: 2rem;
        font-weight: bold;
        padding: 20px 40px;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        text-transform: uppercase;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        animation: pulse 2s infinite;
        margin: 30px 10px;
        text-decoration: none;
        display: inline-block;
        transition: all 0.3s ease;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .cta-button:hover {
        animation: shake 0.5s infinite;
        transform: translateY(-2px);
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        75% {
          transform: translateX(5px);
        }
      }

      .features p {
        font-size: 1.3rem;
        line-height: 1.8;
      }

      @keyframes cardFloat {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      .tokenomics {
        background: rgba(255, 255, 255, 0.95);
        padding: 40px;
        border-radius: 25px;
        margin: 50px 0;
        text-align: center;
        border: 6px dashed #ff6b6b;
        animation: borderColorChange 3s infinite;
        color: #333;
      }

      .tokenomics h2 {
        color: #ff6b6b;
        font-size: 2.5rem;
        margin-bottom: 20px;
      }

      .tokenomics p {
        color: #333;
        font-size: 1.3rem;
        line-height: 1.6;
        margin: 15px 0;
        text-shadow: none;
        font-weight: 500;
      }

      @keyframes borderColorChange {
        0% {
          border-color: #ff6b6b;
        }
        33% {
          border-color: #4ecdc4;
        }
        66% {
          border-color: #45b7d1;
        }
        100% {
          border-color: #ff6b6b;
        }
      }

      img {
        display: block;
        max-width: 400px;
        width: 100%;
        margin: 30px auto;
        border: 8px solid #fff;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        animation: imageFloat 3s ease-in-out infinite;
      }

      @keyframes imageFloat {
        0%,
        100% {
          transform: translateY(0px) rotate(0deg);
        }
        33% {
          transform: translateY(-10px) rotate(1deg);
        }
        66% {
          transform: translateY(5px) rotate(-1deg);
        }
      }

      /* Game Section */
      #game-section {
        background: rgba(255, 255, 255, 0.95);
        padding: 40px;
        border-radius: 25px;
        margin: 50px 0;
        text-align: center;
        border: 6px dashed #4ecdc4;
        animation: borderColorChange 3s infinite;
      }

      #game-section h2 {
        color: #ff6b6b;
        font-size: 2.5rem;
        margin-bottom: 20px;
      }

      #game-section p {
        color: #333;
        font-size: 1.2rem;
        margin: 15px 0;
        text-shadow: none;
        font-weight: 500;
      }

      .stat {
        display: inline-block;
        margin: 0 15px;
        font-size: 1.2rem;
        font-weight: bold;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 10px 15px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      canvas {
        background: rgba(255, 255, 255, 0.9);
        border: 4px solid #ff6b6b;
        border-radius: 15px;
        margin: 20px auto;
        display: block;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        max-width: 100%;
      }

      button {
        font-family: "Comic Neue", cursive;
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 30px;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        margin: 10px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
      }

      .footer {
        text-align: center;
        margin-top: 100px;
        color: #fff;
        font-size: 1.2rem;
        text-shadow: 2px 2px 0px #000;
        padding: 40px 0;
      }

      .footer p {
        margin: 10px 0;
      }

      .footer em {
        font-size: 0.9rem;
        opacity: 0.8;
      }

      /* Floating Animations */
      .falling-can {
        position: fixed;
        width: 30px;
        height: 40px;
        background: linear-gradient(45deg, #ff6b6b, #ffa500, #32cd32);
        border-radius: 5px;
        z-index: 1;
        animation: fall linear infinite;
      }

      @keyframes fall {
        0% {
          transform: translateY(-100px) rotate(0deg);
        }
        100% {
          transform: translateY(100vh) rotate(360deg);
        }
      }

      .rocket {
        position: fixed;
        font-size: 2rem;
        z-index: 1;
        animation: flyRocket linear infinite;
      }

      @keyframes flyRocket {
        0% {
          transform: translateX(-100px) translateY(0) rotate(45deg);
        }
        100% {
          transform: translateX(100vw) translateY(-200px) rotate(45deg);
        }
      }

      .goat {
        position: fixed;
        font-size: 2.5rem;
        z-index: 1;
        animation: flyGoat linear infinite;
      }

      @keyframes flyGoat {
        0% {
          transform: translateX(100vw) translateY(0) scaleX(-1);
        }
        100% {
          transform: translateX(-100px) translateY(-150px) scaleX(-1);
        }
      }

      .hundred-emoji {
        position: fixed;
        font-size: 2rem;
        z-index: 1;
        animation: float100 linear infinite;
      }

      @keyframes float100 {
        0% {
          transform: translateX(-50px) translateY(80vh) rotate(0deg) scale(1);
          opacity: 1;
        }
        50% {
          transform: translateX(50vw) translateY(40vh) rotate(180deg) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translateX(100vw) translateY(10vh) rotate(360deg) scale(1);
          opacity: 0;
        }
      }

      .googly-eye {
        position: fixed;
        font-size: 1.8rem;
        z-index: 1;
        animation: bouncyEye ease-in-out infinite;
      }

      @keyframes bouncyEye {
        0%,
        100% {
          transform: translateY(0) scale(1);
        }
        25% {
          transform: translateY(-30px) scale(1.2);
        }
        50% {
          transform: translateY(-60px) scale(0.8);
        }
        75% {
          transform: translateY(-30px) scale(1.1);
        }
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-3px);
        }
        75% {
          transform: translateX(3px);
        }
      }

      /* Responsive */
      @media (max-width: 768px) {
        h1 {
          font-size: 2.5rem;
        }
        h2 {
          font-size: 1.8rem;
        }
        .container {
          padding: 10px;
        }
        .tokenomics,
        #game-section {
          padding: 20px;
          margin: 30px 0;
        }
        canvas {
          width: 95% !important;
          height: 500px !important;
        }
        .stat {
          margin: 5px;
          padding: 8px 12px;
          font-size: 1rem;
        }
      }

      @media (max-width: 480px) {
        h1 {
          font-size: 2rem;
        }
        canvas {
          height: 400px !important;
        }
        .tokenomics h2,
        #game-section h2 {
          font-size: 2rem;
        }
        .tokenomics p,
        #game-section p {
          font-size: 1.1rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ü•´ AUTISM STACK 100 ü•´</h1>
      <div class="subtitle">"You're not weird. You're just early."</div>

      <section class="features">
        <p>
          üëè Born From the Meme. Forged in Focus.<br />
          üöÄ Solana = Autist-Speed<br />
          üß© Cult of the Stack
        </p>
      </section>

      <section class="tokenomics">
        <h2>üß© YOU'RE NOT WEIRD. YOU'RE JUST EARLY. üß©</h2>
        <p>
          That can-stacking image? It wasn't a meme. It was a calling. A shrine
          to precision. A photo of what every quant, dev, and autist knew deep
          down: order is divine.
        </p>
        <img src="kid-stacking.jpg" alt="Stacker" />
        <p>
          If you've ever rebuilt an API for fun, reorganized your icons by hue,
          or learned Solidity on a Sunday for "clarity"... this is your tribe.
        </p>
        <p style="font-size: 1.4rem; font-weight: bold; color: #ff6b6b">
          üî† $AS100 ‚Äî A MEME, A MOVEMENT
        </p>
        <p>
          <strong>Launching on Pump.fun | 1B Supply | LP Burned Forever</strong>
        </p>
      </section>

      <section id="game-section">
        <h2>üéÆ STACK SIMULATOR 9000 üéÆ</h2>
        <p>
          Enter the sacred ritual of stackers. Test your discipline. Channel
          your inner chart-reading deity. Drop cans. Ascend.
        </p>
        <p><em>Legend says reaching 13 cans reveals the dev's wallet.</em></p>

        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">Best: <span id="best">0</span></div>
        <div class="stat">Stability: <span id="stability">100%</span></div>

        <canvas id="gameCanvas" width="600" height="800"></canvas>

        <div style="text-align: center">
          <button onclick="dropCan()">üì¶ Drop Can</button>
          <button onclick="resetGame()">üîÑ Reset</button>
          <button onclick="pauseGame()">‚è∏Ô∏è Pause</button>
        </div>
      </section>

      <div style="text-align: center; margin: 30px 0">
        <a href="#" class="cta-button">ü•´ BUY $STACK ü•´</a>
        <a href="#" class="cta-button">üìà PUMP.FUN üìà</a>
        <a href="#" class="cta-button">üê¶ TWITTER üê¶</a>
      </div>

      <div class="footer">
        <p>ü•´ Remember: Always stack responsibly! ü•´</p>
        <p>Contract Address: [INSERT SOLANA CONTRACT HERE]</p>
        <p style="margin-top: 20px; font-size: 0.9rem">
          Disclaimer: This is a meme coin. Do your own research. Not financial
          advice. May cause uncontrollable urges to stack cans.
        </p>
      </div>
    </div>

    <script>
      // Game variables
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      let cans = [];
      let currentCan = null;
      let score = 0;
      let best = localStorage.getItem("autismStack100Score") || 0;
      let stability = 100;
      let gameRunning = false;
      let gamePaused = false;
      let mouseX = 300;
      let lastUIUpdate = 0;
      let displayedStability = 100;

      // Sound effects (simple beep sounds)
      const audioContext = new (window.AudioContext ||
        window.webkitAudioContext)();

      function playBeep(frequency = 440, duration = 100) {
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = "square";

        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + duration / 1000
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration / 1000);
      }

      // Can class
      class Can {
        constructor(x, y, isDropping = false) {
          this.x = x;
          this.y = y;
          this.width = 30;
          this.height = 40;
          this.vx = 0;
          this.vy = 0;
          this.isDropping = isDropping;
          this.settled = false;
          this.settleTimer = 0;
          this.color = this.getRandomColor();
        }

        getRandomColor() {
          const colors = [
            "#ff6b6b",
            "#4ecdc4",
            "#45b7d1",
            "#96ceb4",
            "#ffeaa7",
            "#dda0dd",
          ];
          return colors[Math.floor(Math.random() * colors.length)];
        }

        update() {
          if (this.isDropping || !this.settled) {
            // Apply gravity
            this.vy += 0.4;

            // Update position
            this.x += this.vx;
            this.y += this.vy;

            // Apply friction
            this.vx *= 0.95;

            // Ground collision
            const groundY = canvas.height - 30;
            if (this.y + this.height >= groundY) {
              this.y = groundY - this.height;
              this.vy = -this.vy * 0.3;
              this.vx *= 0.8;

              if (Math.abs(this.vy) < 2 && Math.abs(this.vx) < 1) {
                this.vy = 0;
                this.checkSettled();
              }
            }

            // Wall collisions
            if (this.x < 0) {
              this.x = 0;
              this.vx = -this.vx * 0.7;
            }
            if (this.x + this.width > canvas.width) {
              this.x = canvas.width - this.width;
              this.vx = -this.vx * 0.7;
            }

            // Check collisions with other cans
            this.checkCanCollisions();
          }
        }

        checkCanCollisions() {
          cans.forEach((otherCan) => {
            if (otherCan !== this && this.isColliding(otherCan)) {
              this.resolveCollision(otherCan);
            }
          });
        }

        isColliding(other) {
          return (
            this.x < other.x + other.width &&
            this.x + this.width > other.x &&
            this.y < other.y + other.height &&
            this.y + this.height > other.y
          );
        }

        resolveCollision(other) {
          const dx = this.x + this.width / 2 - (other.x + other.width / 2);
          const dy = this.y + this.height / 2 - (other.y + other.height / 2);

          const overlapX = Math.max(
            0,
            Math.min(this.x + this.width, other.x + other.width) -
              Math.max(this.x, other.x)
          );
          const overlapY = Math.max(
            0,
            Math.min(this.y + this.height, other.y + other.height) -
              Math.max(this.y, other.y)
          );

          if (overlapX > 0 && overlapY > 0) {
            if (overlapX < overlapY) {
              // Horizontal separation
              const pushX = overlapX / 2 + 1;
              if (dx > 0) {
                this.x += pushX;
                other.x -= pushX;
              } else {
                this.x -= pushX;
                other.x += pushX;
              }
              this.vx *= 0.8;
              other.vx *= 0.8;
            } else {
              // Vertical separation
              const pushY = overlapY / 2 + 1;
              if (dy > 0) {
                this.y += pushY;
                other.y -= pushY;
                this.vy = Math.max(this.vy, 0.5);
                other.vy = Math.min(other.vy, -0.5);
              } else {
                this.y -= pushY;
                other.y += pushY;
                this.vy = Math.min(this.vy, -0.5);
                other.vy = Math.max(other.vy, 0.5);
              }
            }

            this.settled = false;
            this.settleTimer = 0;
            other.settled = false;
            other.settleTimer = 0;
          }
        }

        checkSettled() {
          if (Math.abs(this.vx) < 0.3 && Math.abs(this.vy) < 0.3) {
            this.settleTimer++;
            if (this.settleTimer > 45) {
              this.settled = true;
              this.isDropping = false;
              this.vx = 0;
              this.vy = 0;
            }
          } else {
            this.settleTimer = 0;
          }
        }

        draw() {
          ctx.save();

          // Enhanced shadow with blur effect
          ctx.shadowColor = "rgba(0,0,0,0.4)";
          ctx.shadowBlur = 4;
          ctx.shadowOffsetX = 3;
          ctx.shadowOffsetY = 3;

          // Can body with improved gradient
          const gradient = ctx.createLinearGradient(
            this.x,
            this.y,
            this.x + this.width,
            this.y + this.height
          );
          gradient.addColorStop(0, this.color);
          gradient.addColorStop(0.5, this.darkenColor(this.color, 0.1));
          gradient.addColorStop(1, this.darkenColor(this.color, 0.3));

          ctx.fillStyle = gradient;
          ctx.fillRect(this.x, this.y, this.width, this.height);

          // Reset shadow for other elements
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;

          // Can rim with metallic effect
          const rimGradient = ctx.createLinearGradient(
            this.x,
            this.y,
            this.x,
            this.y + 6
          );
          rimGradient.addColorStop(0, "#95a5a6");
          rimGradient.addColorStop(0.5, "#34495e");
          rimGradient.addColorStop(1, "#2c3e50");

          ctx.fillStyle = rimGradient;
          ctx.fillRect(this.x, this.y, this.width, 3);
          ctx.fillRect(this.x, this.y + this.height - 3, this.width, 3);

          // Enhanced label with outline
          ctx.fillStyle = "white";
          ctx.font = "bold 14px Comic Neue";
          ctx.textAlign = "center";
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.strokeText(
            "ü•´",
            this.x + this.width / 2,
            this.y + this.height / 2 + 4
          );
          ctx.fillText(
            "ü•´",
            this.x + this.width / 2,
            this.y + this.height / 2 + 4
          );

          // Enhanced stability indicator
          if (!this.settled && this.settleTimer < 20) {
            ctx.strokeStyle = "#ff3838";
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(
              this.x - 3,
              this.y - 3,
              this.width + 6,
              this.height + 6
            );
            ctx.setLineDash([]);
          }
          // Show support indicator for well-supported cans
          else if (this.settled && this.y + this.height < canvas.height - 30) {
            ctx.strokeStyle = "#4ecdc4";
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.strokeRect(
              this.x - 1,
              this.y - 1,
              this.width + 2,
              this.height + 2
            );
            ctx.setLineDash([]);
          }

          ctx.restore();
        }

        darkenColor(color, amount) {
          const hex = color.replace("#", "");
          const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount * 255);
          const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount * 255);
          const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount * 255);
          return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }
      }

      // Game functions
      function initGame() {
        best = localStorage.getItem("autismStack100Score") || 0;
        document.getElementById("best").textContent = best;

        // Responsive canvas
        const maxWidth = Math.min(600, window.innerWidth - 40);
        canvas.width = maxWidth;
        canvas.height = Math.min(800, window.innerHeight * 0.7);

        startGame();
      }

      function startGame() {
        cans = [];
        score = 0;
        gameRunning = true;
        gamePaused = false;
        stability = 100;
        mouseX = canvas.width / 2;

        spawnCan();
        updateUI();
        gameLoop();
      }

      function spawnCan() {
        if (currentCan) return;
        currentCan = new Can(mouseX - 15, 50);
        currentCan.isDropping = false;
      }

      function dropCan() {
        if (!currentCan || !gameRunning || gamePaused) return;

        playBeep(440, 100);
        currentCan.isDropping = true;
        cans.push(currentCan);
        currentCan = null;
        score++;

        setTimeout(() => {
          if (gameRunning) spawnCan();
        }, 500);
      }

      function resetGame() {
        startGame();
      }

      function pauseGame() {
        gamePaused = !gamePaused;
        const btn = document.querySelector('button[onclick="pauseGame()"]');
        btn.textContent = gamePaused ? "‚ñ∂Ô∏è Resume" : "‚è∏Ô∏è Pause";
      }

      function updateUI() {
        // Only update UI every 10 frames to prevent flickering
        const now = Date.now();
        if (now - lastUIUpdate < 100) return; // Update max every 100ms
        lastUIUpdate = now;

        document.getElementById("score").textContent = score;
        document.getElementById("best").textContent = best;

        // Smooth stability changes to prevent flickering
        const targetStability = Math.round(stability);
        const diff = targetStability - displayedStability;

        if (Math.abs(diff) > 0) {
          // Gradually move towards target (prevents sudden jumps)
          displayedStability += Math.sign(diff) * Math.min(Math.abs(diff), 2);

          const stabilityElement = document.getElementById("stability");
          stabilityElement.textContent = displayedStability + "%";

          // Update colors based on displayed stability
          if (displayedStability < 20) {
            stabilityElement.style.color = "#ff3838";
            if (!stabilityElement.parentElement.classList.contains("shaking")) {
              stabilityElement.parentElement.classList.add("shaking");
              stabilityElement.parentElement.style.animation =
                "shake 0.2s infinite";
            }
          } else {
            if (stabilityElement.parentElement.classList.contains("shaking")) {
              stabilityElement.parentElement.classList.remove("shaking");
              stabilityElement.parentElement.style.animation = "none";
            }

            if (displayedStability < 40) {
              stabilityElement.style.color = "#ff6b6b";
            } else if (displayedStability < 60) {
              stabilityElement.style.color = "#ffa500";
            } else {
              stabilityElement.style.color = "#4ecdc4";
            }
          }
        }
      }

      function checkGameOver() {
        // Check for fallen cans
        const lostCans = cans.filter(
          (can) =>
            can.x + can.width < 0 ||
            can.x > canvas.width ||
            can.y > canvas.height ||
            (can.y + can.height >= canvas.height - 30 && Math.abs(can.vx) > 8)
        );

        if (lostCans.length > 0) {
          gameOver();
          return true;
        }

        // Start with full stability
        let stabilityScore = 100;

        if (cans.length === 0) {
          stability = 100;
          return false;
        }

        // Count actively moving/unsettled cans
        const movingCans = cans.filter(
          (can) =>
            !can.settled || Math.abs(can.vx) > 0.5 || Math.abs(can.vy) > 0.5
        );

        // Reduce stability based on movement
        stabilityScore -= movingCans.length * 8;

        // Check for cans that are poorly supported (hanging in air)
        let unsupportedCans = 0;
        cans.forEach((can) => {
          if (can.y + can.height < canvas.height - 35) {
            // Not on ground
            let hasGoodSupport = false;

            cans.forEach((otherCan) => {
              if (otherCan !== can && otherCan.y > can.y) {
                const horizontalOverlap = Math.max(
                  0,
                  Math.min(can.x + can.width, otherCan.x + otherCan.width) -
                    Math.max(can.x, otherCan.x)
                );
                const verticalGap = otherCan.y - (can.y + can.height);

                // Good support = significant overlap and close contact
                if (horizontalOverlap > can.width * 0.4 && verticalGap < 8) {
                  hasGoodSupport = true;
                }
              }
            });

            if (!hasGoodSupport) {
              unsupportedCans++;
            }
          }
        });

        // Heavy penalty for unsupported cans
        stabilityScore -= unsupportedCans * 20;

        // Check overall stack balance (only for stacks of 4+)
        if (cans.length >= 4) {
          const stackCans = cans.filter(
            (can) => can.y + can.height < canvas.height - 35
          );
          if (stackCans.length > 0) {
            const avgX =
              stackCans.reduce((sum, can) => sum + can.x + can.width / 2, 0) /
              stackCans.length;
            const centerX = canvas.width / 2;
            const tiltRatio = Math.abs(avgX - centerX) / (canvas.width / 2);

            // Penalty for extreme tilt (over 30% off center)
            if (tiltRatio > 0.3) {
              stabilityScore -= (tiltRatio - 0.3) * 60;
            }
          }
        }

        // Apply minimal randomness very rarely
        if (Math.random() < 0.05) {
          // Only 5% of the time
          stabilityScore += (Math.random() - 0.5) * 3; // Very small range
        }

        // Keep stability in bounds
        const newStability = Math.max(0, Math.min(100, stabilityScore));

        // Only update stability if change is significant (reduces flickering)
        if (Math.abs(newStability - stability) > 0.5) {
          stability = newStability;
        }

        // Game over if stability hits 0 or below
        if (stability <= 0) {
          gameOver();
          return true;
        }

        return false;
      }

      function gameOver() {
        playBeep(220, 500);
        gameRunning = false;

        if (score > best) {
          best = score;
          localStorage.setItem("autismStack100Score", best);
          alert(`üéâ NEW RECORD! üéâ\nFinal Score: ${score} cans!`);
        } else {
          alert(`Stack collapsed at ${score} cans!\nBest: ${best}`);
        }

        resetGame();
      }

      function gameLoop() {
        if (!gameRunning) return;

        if (!gamePaused) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Enhanced background with better grid
          ctx.strokeStyle = "rgba(255,255,255,0.15)";
          ctx.lineWidth = 1;
          for (let i = 0; i < canvas.width; i += 30) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, canvas.height);
            ctx.stroke();
          }
          for (let i = 0; i < canvas.height; i += 30) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(canvas.width, i);
            ctx.stroke();
          }

          // Enhanced ground with texture
          const groundGradient = ctx.createLinearGradient(
            0,
            canvas.height - 30,
            0,
            canvas.height
          );
          groundGradient.addColorStop(0, "rgba(255,255,255,0.6)");
          groundGradient.addColorStop(1, "rgba(200,200,200,0.8)");
          ctx.fillStyle = groundGradient;
          ctx.fillRect(0, canvas.height - 30, canvas.width, 30);

          // Ground pattern
          ctx.fillStyle = "rgba(0,0,0,0.1)";
          for (let i = 0; i < canvas.width; i += 15) {
            ctx.fillRect(i, canvas.height - 30, 8, 30);
          }

          // Update and draw cans
          cans.forEach((can) => {
            can.update();
            can.draw();
          });

          // Draw current can with enhanced guides
          if (currentCan) {
            currentCan.x = Math.max(
              0,
              Math.min(mouseX - 15, canvas.width - 30)
            );

            // Enhanced drop zone indicator with gradient
            const dropZoneGradient = ctx.createLinearGradient(
              currentCan.x,
              currentCan.y,
              currentCan.x + currentCan.width,
              canvas.height
            );
            dropZoneGradient.addColorStop(0, "rgba(255,255,255,0.1)");
            dropZoneGradient.addColorStop(1, "rgba(255,255,255,0.3)");
            ctx.fillStyle = dropZoneGradient;
            ctx.fillRect(
              currentCan.x,
              currentCan.y,
              currentCan.width,
              canvas.height - currentCan.y - 30
            );

            // Enhanced trajectory line with glow effect
            ctx.shadowColor = "rgba(255,255,255,0.8)";
            ctx.shadowBlur = 5;
            ctx.strokeStyle = "rgba(255,255,255,0.7)";
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.moveTo(
              currentCan.x + currentCan.width / 2,
              currentCan.y + currentCan.height
            );
            ctx.lineTo(currentCan.x + currentCan.width / 2, canvas.height - 30);
            ctx.stroke();
            ctx.setLineDash([]);

            // Reset shadow
            ctx.shadowColor = "transparent";
            ctx.shadowBlur = 0;

            currentCan.draw();
          }

          checkGameOver();
          updateUI();
        }

        requestAnimationFrame(gameLoop);
      }

      // Event listeners
      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
      });

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        mouseX = e.touches[0].clientX - rect.left;
      });

      canvas.addEventListener("click", dropCan);
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        dropCan();
      });

      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          dropCan();
        }
      });

      window.addEventListener("resize", () => {
        const maxWidth = Math.min(600, window.innerWidth - 40);
        canvas.width = maxWidth;
        canvas.height = Math.min(800, window.innerHeight * 0.7);
      });

      // Background animations
      function createFallingCan() {
        const can = document.createElement("div");
        can.className = "falling-can";
        can.style.left = Math.random() * 100 + "vw";
        can.style.animationDuration = Math.random() * 3 + 2 + "s";
        can.style.background = `linear-gradient(45deg, 
              hsl(${Math.random() * 360}, 70%, 60%), 
              hsl(${Math.random() * 360}, 70%, 60%))`;
        document.body.appendChild(can);

        setTimeout(() => can.remove(), 5000);
      }

      function createRocket() {
        const rocket = document.createElement("div");
        rocket.className = "rocket";
        rocket.innerHTML = "üöÄ";
        rocket.style.top = Math.random() * 80 + "vh";
        rocket.style.animationDuration = Math.random() * 4 + 3 + "s";
        document.body.appendChild(rocket);

        setTimeout(() => rocket.remove(), 7000);
      }

      function createGoat() {
        const goat = document.createElement("div");
        goat.className = "goat";
        goat.innerHTML = "üêê";
        goat.style.top = Math.random() * 60 + "vh";
        goat.style.animationDuration = Math.random() * 5 + 4 + "s";
        document.body.appendChild(goat);

        setTimeout(() => goat.remove(), 9000);
      }

      function createGooglyEye() {
        const eye = document.createElement("div");
        eye.className = "googly-eye";
        eye.innerHTML = "üßô‚Äç‚ôÇÔ∏è";
        eye.style.left = Math.random() * 85 + "vw";
        eye.style.top = Math.random() * 70 + "vh";
        eye.style.animationDuration = Math.random() * 2 + 1.5 + "s";
        document.body.appendChild(eye);

        setTimeout(() => {
          if (eye.parentNode) eye.remove();
        }, 8000);
      }

      function createHundredEmoji() {
        const hundred = document.createElement("div");
        hundred.className = "hundred-emoji";
        hundred.innerHTML = "üíØ";
        hundred.style.left = Math.random() * 85 + "vw";
        hundred.style.top = Math.random() * 70 + "vh";
        hundred.style.animationDuration = Math.random() * 2 + 1.5 + "s";
        hundred.style.color = "#ff1493";
        hundred.style.fontWeight = "bold";
        hundred.style.textShadow = "2px 2px 0px #000";
        document.body.appendChild(hundred);

        setTimeout(() => {
          if (hundred.parentNode) hundred.remove();
        }, 8000);
      }

      // Start background animations
      setInterval(createFallingCan, 800);
      setInterval(createRocket, 2000);
      setInterval(createGoat, 3000);
      setInterval(createGooglyEye, 2500);
      setInterval(createHundredEmoji, 2000);

      // Click effects
      document.addEventListener("click", function (e) {
        const emojis = ["ü•´", "üöÄ", "üêê", "üìà", "üíé", "üåô", "‚ö°", "üßô‚Äç‚ôÇÔ∏è", "üíØ"];

        for (let i = 0; i < 5; i++) {
          const particle = document.createElement("div");
          particle.innerHTML =
            emojis[Math.floor(Math.random() * emojis.length)];
          particle.style.position = "fixed";
          particle.style.left = e.clientX + "px";
          particle.style.top = e.clientY + "px";
          particle.style.fontSize = "20px";
          particle.style.pointerEvents = "none";
          particle.style.zIndex = "1000";
          particle.style.animation = `particle-explosion 1s ease-out forwards`;

          const keyframes = `
                @keyframes particle-explosion {
                    0% { transform: translate(0, 0) scale(1); opacity: 1; }
                    100% { 
                        transform: translate(${
                          (Math.random() - 0.5) * 200
                        }px, ${(Math.random() - 0.5) * 200}px) scale(0); 
                        opacity: 0; 
                    }
                }
            `;

          if (!document.querySelector("#particle-style")) {
            const style = document.createElement("style");
            style.id = "particle-style";
            style.textContent = keyframes;
            document.head.appendChild(style);
          }

          document.body.appendChild(particle);

          setTimeout(() => {
            particle.remove();
          }, 1000);
        }
      });

      // Konami code easter egg
      let konamiCode = [];
      const konamiSequence = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65];

      document.addEventListener("keydown", function (e) {
        konamiCode.push(e.keyCode);
        if (konamiCode.length > konamiSequence.length) {
          konamiCode.shift();
        }

        if (JSON.stringify(konamiCode) === JSON.stringify(konamiSequence)) {
          document.body.style.animation = "shake 0.1s infinite";

          for (let i = 0; i < 50; i++) {
            setTimeout(() => {
              createFallingCan();
              createRocket();
              createGoat();
              createGooglyEye();
              createHundredEmoji();
            }, i * 100);
          }

          setTimeout(() => {
            document.body.style.animation = "";
          }, 5000);
        }
      });

      // Initialize game
      window.addEventListener("load", initGame);
    </script>
  </body>
</html>
